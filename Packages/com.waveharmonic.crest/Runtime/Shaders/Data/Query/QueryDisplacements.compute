// Crest Water System
// Copyright © 2024 Wave Harmonic. All rights reserved.

#pragma kernel CrestExecute

// Must match value in script
#define GROUP_SIZE 64

StructuredBuffer<float3> _Crest_QueryPositions_MinimumGridSizes;
RWStructuredBuffer<float3> _Crest_ResultDisplacements;

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"

#include "../../Library/Macros.hlsl"
#include "../../Library/Globals.hlsl"
#include "../../Library/InputsDriven.hlsl"
#include "../../Library/Helpers.hlsl"
#include "../../Library/Cascade.hlsl"

m_CrestNameSpace

float3 ComputeDisplacement(float2 undispPos, float minSlice, const float baseScale)
{
    uint slice0, slice1;
    float lodAlpha;
    // Do not use last slice - this is a 'transition' slice used to cross-fade waves
    // between LOD resolutions to avoid pops. That being said, this will have clamped
    // samples leading to objects floating on waves that do not exist.
    PosToSliceIndices(undispPos, minSlice, g_Crest_LodCount - 2.0, baseScale, slice0, slice1, lodAlpha);

    const float wt_0 = (1. - lodAlpha) * Cascade::Make(slice0)._Weight;
    const float wt_1 = (1. - wt_0) * Cascade::Make(slice1)._Weight;

    // Displacement
    float3 disp;
    {
        const Cascade cascade0 = Cascade::MakeAnimatedWaves(slice0);
        const Cascade cascade1 = Cascade::MakeAnimatedWaves(slice1);

        disp =
            wt_0 * cascade0.SampleDisplacement(undispPos) +
            wt_1 * cascade1.SampleDisplacement(undispPos);
    }

    return disp;
}

void Execute(uint3 id)
{
    float3 data = _Crest_QueryPositions_MinimumGridSizes[id.x];
    const float2 queryPosXZ = data.xy;
    const float minGridSize = data.z;

    const float gridSizeSlice0 = Cascade::MakeAnimatedWaves(0)._Texel;
    // Displacements should not utilize the last slice which is used for transitioning waves between
    // sampling resolutions
    const float minSlice = clamp(floor(log2(max(minGridSize / gridSizeSlice0, 1.0))), 0.0, g_Crest_LodCount - 2.0);

    // Perform iteration to invert the displacement vector field - find position that displaces to query position,
    // and return displacement at that point.

    float2 undispPos = queryPosXZ;
    for (int i = 0; i < 4; i++)
    {
        float3 displacement = ComputeDisplacement(undispPos, minSlice, g_Crest_WaterScale);

        float2 error = (undispPos + displacement.xz) - queryPosXZ;

        undispPos -= error;
    }

    _Crest_ResultDisplacements[id.x] = ComputeDisplacement(undispPos, minSlice, g_Crest_WaterScale);
}

m_CrestNameSpaceEnd

[numthreads(GROUP_SIZE, 1, 1)]
m_CrestKernel(Execute)
